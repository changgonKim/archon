"""
This type stub file was generated by pyright.
"""

import asyncio

class TCPProtocol(asyncio.Protocol):
    """A TCP server/client based on asyncio protocols.

    This is a high-level implementation of the client and server asyncio
    protocols. See `asyncio protocol
    <https://docs.python.org/3/library/asyncio-protocol.html>`__ for details.

    Parameters
    ----------
    loop
        The event loop. The current event loop is used by default.
    connection_callback
        Callback to call when a new client connects.
    data_received_callback
        Callback to call when a new data is received.
    max_connections : int
        How many clients the server accepts. If `None`, unlimited connections
        are allowed.

    """
    def __init__(self, loop=..., connection_callback=..., data_received_callback=..., max_connections=...) -> None:
        ...
    
    @classmethod
    async def create_server(cls, host, port, **kwargs):
        """Returns a `~asyncio.Server` connection."""
        ...
    
    @classmethod
    async def create_client(cls, host, port, **kwargs):
        """Returns a `~asyncio.Transport` and `~asyncio.Protocol`."""
        ...
    
    def connection_made(self, transport):
        """Receives a connection and calls the connection callback."""
        ...
    
    def data_received(self, data):
        """Decodes the received data."""
        ...
    
    def connection_lost(self, exc):
        """Called when connection is lost."""
        ...
    


class PeriodicTCPServer(TCPProtocol):
    """A TCP server that runs a callback periodically.

    Parameters
    ----------
    period_callback
        Callback to run every iteration.
    sleep_time : float
        The delay between two calls to ``periodic_callback``.
    kwargs : dict
        Parameters to pass to `TCPProtocol`

    """
    def __init__(self, periodic_callback=..., sleep_time=..., **kwargs) -> None:
        ...
    
    @classmethod
    async def create_client(cls, *args, **kwargs):
        ...
    
    @classmethod
    async def create_server(cls, host, port, *args, **kwargs):
        """Returns a `~asyncio.Server` connection."""
        ...
    
    @property
    def periodic_callback(self):
        """Returns the periodic callback."""
        ...
    
    @periodic_callback.setter
    def periodic_callback(self, func):
        """Sets the periodic callback."""
        ...
    


class TCPStreamServer(object):
    """A TCP server based on asyncio streams.

    This is a high-level implementation of the asyncio server using
    streams. See `asyncio streams
    <https://docs.python.org/3/library/asyncio-stream.html>`__ for details.

    Parameters
    ----------
    host : str
        The server host.
    port : int
        The server port.
    connection_callback
        Callback to call when a new client connects or disconnects.
    data_received_callback
        Callback to call when a new data is received.
    loop
        The event loop. The current event loop is used by default.
    max_connections : int
        How many clients the server accepts. If `None`, unlimited connections
        are allowed.

    """
    def __init__(self, host, port, connection_callback=..., data_received_callback=..., loop=..., max_connections=...) -> None:
        ...
    
    async def start(self):
        """Starts the server and returns a `~asyncio.Server` connection."""
        ...
    
    def stop(self):
        """Stops the server."""
        ...
    
    def serve_forever(self):
        """Exposes ``TCPStreamServer.server.serve_forever``."""
        ...
    
    def is_serving(self):
        ...
    
    async def connection_made(self, reader, writer):
        """Called when a new client connects to the server.

        Stores the writer protocol in ``transports``, calls the connection
        callback, if any, and starts a loop to read any incoming data.

        """
        ...
    


class TCPStreamClient:
    """An object containing a writer and reader stream to a TCP server."""
    def __init__(self, host, port) -> None:
        ...
    
    async def open_connection(self):
        """Creates the connection."""
        ...
    
    def close(self):
        """Closes the stream."""
        ...
    


async def open_connection(host, port):
    """Returns a TCP stream connection with a writer and reader.

    This function is equivalent to doing ::

        >>> client = TCPStreamClient('127.0.0.1', 5555)
        >>> await client.open_connection()

    Instead just do ::

        >>> client = await TCPStreamClient('127.0.0.1', 5555)
        >>> client.writer.write('Hi!\\n'.encode())

    Parameters
    ----------
    host : str
        The host of the TCP server.
    port : int
        The port of the TCP server.

    Returns
    -------
    client : `.TCPStreamClient`
        A container for the stream reader and writer.

    """
    ...

class TCPStreamPeriodicServer(TCPStreamServer):
    """A TCP server that calls a function periodically.

    Parameters
    ----------
    host : str
        The server host.
    port : int
        The server port.
    period_callback
        Callback to run every iteration. It is called for each transport
        that is connected to the server and receives the transport object.
    sleep_time : float
        The delay between two calls to ``periodic_callback``.
    kwargs : dict
        Parameters to pass to `TCPStreamServer`

    """
    def __init__(self, host, port, periodic_callback=..., sleep_time=..., **kwargs) -> None:
        ...
    
    async def start(self):
        """Starts the server and returns a `~asyncio.Server` connection."""
        ...
    
    def stop(self):
        ...
    
    @property
    def periodic_callback(self):
        """Returns the periodic callback."""
        ...
    
    @periodic_callback.setter
    def periodic_callback(self, func):
        """Sets the periodic callback."""
        ...
    


class TopicListener(object):
    """A class to declare and listen to AMQP queues with topic conditions.

    Parameters
    ----------
    url : str
        RFC3986 formatted broker address. When used, the other keyword
        arguments are ignored.
    user : str
        The user to connect to the RabbitMQ broker.
    password : str
        The password for the user.
    host : str
        The host where the RabbitMQ message broker runs.
    virtualhost : str
         Virtualhost parameter. ``'/'`` by default.
    port : int
        The port on which the RabbitMQ message broker is running.
    ssl : bool
        Whether to use TLS/SSL connection.

    """
    def __init__(self, url=..., user=..., password=..., host=..., virtualhost=..., port=..., ssl=...) -> None:
        ...
    
    async def connect(self, exchange_name, exchange_type=...):
        """Initialise the connection.

        Parameters
        ----------
        exchange_name : str
            The name of the exchange to create.
        exchange_type : str
            The type of exchange to create.

        """
        ...
    
    async def add_queue(self, queue_name, callback=..., bindings=...):
        """Adds a queue with bindings.

        Parameters
        ----------
        queue_name : str
            The name of the queue to create.
        callback
            A callable that will be called when a new message is received in
            the queue. Can be a coroutine.
        bindings : list or str
            The list of bindings for the queue. Can be a list of string or a
            single string in which the bindings are comma-separated.

        """
        ...
    
    async def stop(self):
        """Cancels queues and closes the connection."""
        ...
    



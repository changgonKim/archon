#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# @Author: José Sánchez-Gallego (gallegoj@uw.edu)
# @Date: 2021-01-19
# @Filename: archon.py
# @License: BSD 3-clause (http://www.opensource.org/licenses/BSD-3-Clause)

from __future__ import annotations

import asyncio
import re
import warnings

from typing import Optional

from clu.device import Device

from archon.controller.command import ArchonCommand
from archon.exceptions import ArchonError, ArchonUserWarning

from . import MAX_COMMAND_ID

__all__ = ["ArchonController"]


class ArchonController(Device):
    """Talks to an Archon controller over TCP/IP.

    Parameters
    ----------
    host
        The hostname of the Archon.
    port
        The port on which the Archon listens to incoming connections.
        Defaults to 4242.
    name
        A name identifying this controller.
    """

    __running_commands: dict[int, ArchonCommand] = {}
    __next_id = 0

    def __init__(self, host: str, port: int = 4242, name: str = ""):
        self.name = name
        super().__init__(host, port)

        # TODO: asyncio recommends using asyncio.create_task directly, but that
        # call get_running_loop() which fails in iPython.
        self._job = asyncio.get_event_loop().create_task(self.__track_commands())

    def send_command(
        self,
        command_string: str,
        command_id: Optional[int] = None,
        **kwargs,
    ) -> ArchonCommand:
        """Sends a command to the Archon.

        Parameters
        ----------
        command_string
            The command to send to the Archon. Will be converted to uppercase.
        command_id
            The command id to associate with this message. If not provided, a
            sequential, autogenerated one will be used.
        kwargs
            Other keyword arguments to pass to `.ArchonCommand`.
        """
        command_id = command_id or self.__get_id()
        if command_id > MAX_COMMAND_ID or command_id < 0:
            raise ArchonError(
                f"Command ID must be in the range [0, {MAX_COMMAND_ID:d}]."
            )

        command = ArchonCommand(
            command_string,
            command_id,
            **kwargs,
        )
        self.__running_commands[command_id] = command

        self.write(command.raw)

        return command

    async def process_message(self, line: bytes) -> None:
        """Processes a message from the Archon and associates it with its command."""
        match = re.match(b"^[<|?]([0-9A-F]{2})", line)
        if match is None:
            warnings.warn(
                f"Received invalid command {line.decode()}", ArchonUserWarning
            )

        command_id = int(match[1], 16)
        if command_id not in self.__running_commands:
            warnings.warn(f"Cannot find running command for {line}", ArchonUserWarning)
            return

        self.__running_commands[command_id].process_reply(line)

    async def stop(self):
        """Stops the client and cancels the command tracker."""
        self._job.cancel()
        await super().stop()

    async def _listen(self):
        """Listens to the reader stream and callbacks on message received."""
        if not self._client:  # pragma: no cover
            raise RuntimeError("Connection is not open.")

        while True:
            # Max length of a reply is 1024 bytes for the message preceded by <xx:
            # We read the first four characters (the maximum length of a complete
            # message: ?xx\n). If the message ends in a newline, we are done;
            # if the message ends with ":", it means what follows are 1024 binary
            # characters without a newline; otherwise, read until the newline which
            # marks the end of this message. In binary, if the response is < 1024
            # bytes, the remaining bytes are filled with NULL (0x00).
            line = await self._client.reader.read(4)

            if line[-1] == ord(b"\n"):
                pass
            elif line[-1] == ord(b":"):
                line += await self._client.reader.read(1024)
            else:
                line += await self._client.reader.readuntil(b"\n")

            self.notify(line)

    def __get_id(self) -> int:
        """Returns an identifier and increases the counter."""
        id = self.__next_id
        self.__next_id += 1
        if self.__next_id > 2 ** 8 - 1:
            self.__next_id = 0
        return id

    async def __track_commands(self):
        """Removes complete commands from the list of running commands."""
        while True:
            self.__running_commands = {
                cid: cmd
                for (cid, cmd) in self.__running_commands.items()
                if cmd.status == cmd.status.RUNNING
            }
            await asyncio.sleep(0.5)
